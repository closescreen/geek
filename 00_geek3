#!/usr/bin/env perl
use strict;
use warnings;
use Data::Dumper;


my $g = Geek->new( );
my %sm = $g->named_groups(
    day => '\d\d\d\d-\d\d-\d\d',
    hour => '\d\d\d\d-\d\d-\d\dT\d\d',
    job => '\w+',
    typenum => '\d+',
);

# 'set -o pipefail; mkdir -p %d && netflag --local --file="%f.FLAG" -cmd=\'' . $via_flag_cmd . '\'' . ( $compress ? " | $compress " : '' ). ' > %f.TMP && mv %f.TMP %f'	

$g->routes(
    {	target=>"../RESULT/10/$sm{day}/google/3/url_groups.gz",
	need=>{
	    # here sub return code:
	    dom_grNdays => sub{ "glob://../RESULT/10/$+{day}/google/3/*.gz" },
	    concrete1 => sub{ "../RESULT/10/$+{day}/google/3/dom_gr1days.gz"},
	    concrete2 => sub{ "../RESULT/10/$+{day}/google/3/dom_gr2days.gz"},
	},
	cmd => sub{
	    sub{  }
	},
    
    },
    { 	target=>"../RESULT/10/$sm{day}/google/3/sz_vars_30days.gz", 
	need=>{ 
	    bids => sub{
		# в данном случае возвращается arrayref, в котором список строк - значит это список файлов
		$g->days( from=>$+{day}, n=>-3 )->files( "../RESULT/10/\%F/google/3/bids.gz" );
	    },
	    total => sub{
		$g->days( from=>$+{day}, n=>-3 )->files( "../RESULT/10/\%F/google/0/total.gz" );
	    },
	},
	
	# определенные пользователем переменные - ,желательно, в нижнем регистре, предопределенные - в верхнем.
#	cmd => sub{"I return: day:$+{day}, target:$+{TARGET}, total:'$+{total}', bids:'$+{bids}'"},
	
	cmd => sub{
	    sub{ print Dumper \@_ },
	    $+{TARGET}, "'$+{total}'", "'$+{bids}'"
	},

    },
    { 	target => "../RESULT/10/$sm{day}/google/3/bids.gz",
	    need => {
		total => sub{ "../RESULT/10/$+{day}/google/3/total.gz" },
	    },
	cmd => sub{
	    "hello $+{TARGET}"
	},	
    },
    {
	target => "../RESULT/10/$sm{day}/google/3/total.gz",
    },

);

#die Dumper $g;

my @wanted = ( "../RESULT/10/2014-10-02/google/3/sz_vars_30days.gz",
    "../RESULT/10/2014-10-02/google/3/url_groups.gz", 
);

my %matched = $g->match( wanted=>\@wanted );
warn Dumper \%matched;
die;

$g->have( matched=>\%matched );
warn Dumper \%matched;



#------------ Geek -----------
package Geek;
use Data::Dumper;
use Date::Calc;

sub new{
 my $pkg = shift or die "Package! Usage: Geek->new()";
 my %se = ();
 return bless \%se;
};

sub uniq{
 # give LIST  
 # Return uniqued LIST
 if ( ref $_[0] eq "Geek" ){
    shift;
 }
 my %rv = map {$_,$_} @_;
 return wantarray ? (values %rv) : [values %rv];
}


sub routes{
 my $se = shift;
 ref $se or die "First param must be a reference to Geek object";
 $se->{routes} = \@_;
 
 return $se;
}

sub match{
 # gives "wanted", returns "jobs"
 my $se = shift;
 ref $se eq "Geek" or die "First param must be a reference to Geek object"; 
 my %pa = @_;
 my $wanted = $pa{ wanted };
 my $skip_test = $pa{ skip_test }; # (skip_test=>1 - не проверять наличие файлов)
 my @matched_routes;
 if ( !$se->{routes} ){ die "routes is empty." }
 my %rv; 

 for my $r ( @{ $se->{routes}||[] } ){
    if ( my $re = $r->{target} ){
	for my $wanted_elem ( @$wanted ){ # level I
	    if ( $wanted_elem=~$re ){
		#$rv{ $wanted_elem }{ target } = $wanted_elem;
		if ( my $need = $r->{need} ){
		    if ( ref $need eq "HASH"){
			for my $type ( keys %$need ){
			    my $need_smf = $need->{$type};
			    if (ref $need_smf eq "CODE"){
				my @need_smf = $need_smf->();
				#$rv{ $re }{ $wanted_elem }{ need }{ $type } = \@need_smf; 
				$rv{ $wanted_elem }{ need }{ $type } = { map { $_, $skip_test ? undef : scalar($se->test($_)) } @need_smf };
				#warn "need $type = @need_smf";
			    }
			}
		    }
		}
		
		if ( my $cmd = $r->{cmd} ){
		    my $re2; my $str2;
		    my %named_groups = ( TARGET=>[$wanted_elem], %{ $rv{ $wanted_elem }{ need }||{} } );
		    #die Dumper \%named_groups;
		    for my $name ( keys %named_groups ){
			my $value;
			if ( ref $named_groups{$name} eq "ARRAY" ){
			    $value = join(" ", @{ $named_groups{$name} } );
			}else{
			    $value = $named_groups{$name};
			}
			
			my $escaped = quotemeta $value;
			#$escaped=~s/([?])/\\$1/g;
			
			$re2.="-$name-(?<$name>$escaped)";
			$str2.="-$name-$value";
		    }
		    my $str1 = "$wanted_elem$str2";
		    my $re1 = qr/$re$re2/;
	    	    die "---NOT MATCHED $str1 to $re1---" if not "$str1"=~$re1;
		    my @job = $cmd->();
		    if ( !@job ){
			die "empty job returned.".Dumper( \$rv{ $wanted_elem } );
		    #}elsif (@job==1){
		    #	$target->{job} = $job[0];
		    }else{
			#$target->{job} = \@job;
			$rv{$wanted_elem}{ job } = \@job;
		    }
		}
	    }
	}
    }
 }

 return wantarray ? %rv : \%rv;
}

#sub escape{
# my $se = shift or die "SE!";
# my $str = shift or die "string!";
#}

sub test{
 # testing files
 my $se = shift or die "SE!";
 my %proto_testers = (
    default => sub{ -s $_ && $_ },
    dfs => sub{ system("bash","-c","hadoop fs -ls $_ | grep $_") },
    "glob" => sub { join " ", <${_}> },
 ); 
 if ( ref $_[0] eq "HASH" ){
    %proto_testers = %{ shift() };
 }

 my @fnames = @_;
 my %rv;

 for my $name (grep {$_} @fnames){
    $name=~s|((\w+)\:\/\/)||;
    my $proto =$2||"default";
    my $tester_code = $proto_testers{ $proto } or warn "Not found tester code for proto '$proto'. File:'$name'";
    ref $tester_code eq "CODE" or die "Tester code must be a CODE ref ".Dumper(\%proto_testers);
    for ( $name ){
	$rv{ $name } = &$tester_code;
    }
 }

 if ( @fnames==1 ){
    if (! wantarray){
	return [values %rv]->[0];	
    }
 }

 return wantarray ? %rv : \%rv;
}

sub days{
 my $se = shift or die "First param must be a reference to Geek object";
 #ref $se eq "Geek" or die "First param must be a reference to Geek object";
 my %pa = @_;
 my @rv;
 if ($pa{from} and $pa{n}){
    my $n = $pa{n};
    my ($y,$m,$d)=$pa{from}=~/(\d\d\d\d)-(\d\d)-(\d\d)/;
    $y and $m and $d or die "bad parameter from=$pa{from}";
    my @ii = $n>0 ? (0..$n) : ($n..-1);
    for my $i ( @ii ){
	push @rv, [ Date::Calc::Add_Delta_Days($y,$m,$d, $i) ];
    }
 }
 @rv = map {sprintf("%d-%02d-%02d",@$_)} @rv;
 my $days = Geek::Days->new('days');
 $days->days(\@rv);
 return $days;
}


sub named_groups{
 ref shift or die "First param must be a reference to Geek object";
 my %pa = @_;
 my %rv;
 for my $name (keys %pa){
    my $v = $pa{$name};
    #$rv{ $name } = qr/(?<$name>$pa{$name})/; 
    $rv{ $name } = "(?<$name>$pa{$name})"; 
 }
 return wantarray ? %rv : \%rv;
}


#-----------------------------------------------------------------
package Geek::Days;
use base qw|Object::Accessor|;

sub files{
 my $se = shift or die "se!";
 my $tmpl = shift or die "tmpl!";
 my @rv;
 for my $d ( @{ $se->days() } ){
    my $file = $tmpl;
    $file=~s/\%F/$d/g;
    push @rv, $file;
 }
 if (wantarray){
    return @rv;
 }else{
    my $files = Geek::Files->new('files');
    $files->files(\@rv);
    return $files;
 }
}




1;
