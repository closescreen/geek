#!/usr/bin/env perl

use strict;
use warnings;
use Data::Dumper;
use Getopt::Long;
use FindBin qw($Bin);


my $usage = q{ Usage: };

my @wanted_fields;
my @parsers = sort <$Bin/field_reader.parser.type*> or warn "not found any parser as $Bin/field_reader.parser.type*";
my $ifs = "*";
my $ofs = "*";
my $deb;
my $reader = "awk";
my $show_command;
my $show_fields;
my @definitions_files;
my @labels;
GetOptions(
    'want|fields|want-fields|want_fields=s' => \@wanted_fields, #which fields to read
    'parsers=s' => \@parsers, # which parsers parsers to use
    'definitions|defined-in|defined_in=s' => \@definitions_files,
    'debug' => \$deb,
    'ifs=s' => \$ifs,
    'ofs=s' => \$ofs,
    'show_command|show-command|show-cmd' => \$show_command,
    'show_fields|show-fields' => \$show_fields,
    'labels=s' => \@labels,
) or die "Bad opt!";


@parsers = grep {$_} split /[\,\s]+/, join ",", @parsers or die "$0: parsers list are empty! ";
@definitions_files = grep {$_} split /[\,\s]+/, join ",", @definitions_files;


@labels = grep {$_} split /[\,\s]+/, join ",", @labels;

my @found_fields;

if (@labels){
    warn "labels: @labels" if $deb;
    if ( my ($sep_defined_in_labels) = $labels[0]=~/([\s\*\|\,\;\t])/){
	$ifs = shift @labels;
	warn "Input field separator: $ifs" if $deb;
    }
    @found_fields = @labels;

}elsif(@definitions_files){
    for my $parser (@parsers){
	if ( my $found_fields = `$parser @definitions_files` ){
	    if ( @found_fields = grep {$_} split /\s+/, $found_fields ){
		warn "Found fields are: '@found_fields' in @definitions_files parser:$parser" if $deb;
		last
	    }    
	}
    }
}else{
 die "$0: Option --defined or --labels must be defined";
}

@definitions_files and @labels and die "Both defined --defined and -labels: must be only one from it.";

$"=",";
warn "wanted_fields are: '@wanted_fields' parsers are: '@parsers'" if $deb;



# -- only print fields:
$,=" ";
print @found_fields and exit if $show_fields; 

@wanted_fields = grep {$_} split /[\,\s]+/, join ",", @wanted_fields or die "$0: wanted_fields list is empty";

my %found_fields;
for my $i (0..$#found_fields){
 $found_fields{ $found_fields[$i] } = $i+1;
}


for my $wanted_field ( @wanted_fields ){
    die "Not found field '$wanted_field' in @definitions_files" if not $found_fields{ $wanted_field };
}


my %readers = (
 awk => sub{ "awk -F$ifs -vOFS=$ofs '{ print ".join(",",map {"\$$_"} @found_fields{@_})."}'" }
);

my $reader_sub = $readers{$reader} or die "No such reader: $reader";
my $reader_cmd = $reader_sub->( @wanted_fields ) or die "can't create reader command for wanted_fields @wanted_fields";
warn "reader command: $reader_cmd" if $deb;

print $reader_cmd and exit if $show_command;

warn "execute $reader_cmd ..." if $deb;
exec 'bash','-c',$reader_cmd;



