#!/usr/bin/env perl

use strict;
use warnings;
use Data::Dumper;
use Getopt::Long;

#my $usage = q{ Usage: };
#GetOptions(
#    
#) or die "Bad opt!";

#my %some = (
# day => qr/(?<day>\d\d\d\d-\d\d-\d\d)/,
# 
#);

my $geek = Geek->new( );
my %sm = $geek->named_groups(
    day => '\d\d\d\d-\d\d-\d\d',
    hour => '\d\d\d\d-\d\d-\d\dT\d\d',
    job => '\w+',
    typenum => '\d+',
);

$geek->routes(
    { for_files=>"../RESULT/10/$sm{day}/google/3/sz_vars_30days.gz", 
	need_files=>{ 
	    bids=> sub{ 
		$geek->days( from=>$+{day}, n=>-30 )->files( "../RESULT/10/\%F/google/3/bids.gz" );
	    },
	    total=>sub{
		$geek->days( from=>$+{day}, n=>-30 )->files( "../RESULT/10/\%F/google/0/total.gz" );
	    }, 
	},
    },
    { for_files=>"../RESULT/10/$sm{day}/google/3/bids.gz",
	need_files=>{
	    total=>sub{ "../RESULT/10/$+{day}/3/total.gz" },
	},
    },
);


my @wanted_files = ( "../RESULT/10/2014-09-15/google/3/sz_vars_30days.gz",
    "../RESULT/10/2014-09-02/google/3/sz_vars_30days.gz", 
    "../RESULT/10/2014-09-02/google/3/bids.gz", 
    );

my $matched = $geek->for_files(@wanted_files);
die Dumper $matched;

for my $wf (@wanted_files){
    for my $t ( $matched->types( arg=>"$wf" ) ){
	my @need = $matched->files(arg=>"$wf",type=>$t);
	print "wanted=$wf, type=$t\n".join("\n", @need )."\n" ;
    }	
}





#------------ Geek -----------
package Geek;
use Data::Dumper;
use Date::Calc;

sub new{
 my $pkg = shift or die "Package! Usage: Geek->new()";
 my %se = ();
 return bless \%se;
};

sub debug{
 my $se = shift or die "self!";
 if ( defined $_[0] ){
    $se->{debug} = $_[0];
    return $se;
 }else{
    return $se->{debug}
 }
 
}

sub routes{
 my $se = shift;
 ref $se or die "First param must be a reference to Geek object";
 $se->{routes} = Geek::Routes->new('routes','debug');
 $se->{routes}->debug(1) if $se->{debug};
 $se->{routes}->routes( \@_ );
 
 return $se;
}

sub for_files{ 
 my $se = shift;
 ref $se eq "Geek" or die "First param must be a reference to Geek object";
 return $se->match( cond=>"for_files", args=>\@_ ); 
}

sub match{
 my $se = shift;
 ref $se eq "Geek" or die "First param must be a reference to Geek object"; 
 my %pa = @_;
 my $cond = $pa{ cond };
 my $args = $pa{ args };
 my @matched_routes;
 if (!$se->{routes}){ die "routes is empty." }
 my @rv;
 for my $r ( @{ $se->{routes}->routes()||[] } ){
    if ( my $re = $r->{$cond} ){
	for my $arg ( @$args ){
	    if ( $arg=~$re ){
		if ( my $need_files = $r->{need_files} ){
		    if ( ref $need_files eq "HASH"){
			for my $type ( keys %$need_files ){
			    my $need = $need_files->{$type};
			    if (ref $need eq "CODE"){
				my @need_file_names = $need->();
				push @rv, { arg=>$arg, cond=>$cond, re=>$re, route=>$r, type=>$type, files=>\@need_file_names } ;
			    }
			}
		    }
		}
	    }
	}
    }
 }
 my $routes = Geek::Routes->new( 'routes','debug' ); 
 $routes->debug( $se->{debug}||0 );
 $routes->routes( \@rv );
 return $routes;
}


sub days{
 my $se = shift or die "First param must be a reference to Geek object";
 #ref $se eq "Geek" or die "First param must be a reference to Geek object";
 my %pa = @_;
 my @rv;
 if ($pa{from} and $pa{n}){
    my $n = $pa{n};
    my ($y,$m,$d)=$pa{from}=~/(\d\d\d\d)-(\d\d)-(\d\d)/;
    $y and $m and $d or die "bad parameter from=$pa{from}";
    my @ii = $n>0 ? (0..$n) : ($n..-1);
    for my $i ( @ii ){
	push @rv, [ Date::Calc::Add_Delta_Days($y,$m,$d, $i) ];
    }
 }
 @rv = map {sprintf("%d-%02d-%02d",@$_)} @rv;
 my $days = Geek::Days->new('days');
 $days->days(\@rv);
 return $days;
}


sub named_groups{
 ref shift or die "First param must be a reference to Geek object";
 my %pa = @_;
 my %rv;
 for my $name (keys %pa){
    my $v = $pa{$name};
    #$rv{ $name } = qr/(?<$name>$pa{$name})/; 
    $rv{ $name } = "(?<$name>$pa{$name})"; 
 }
 return wantarray ? %rv : \%rv;
}

#-----------------------------------------------------------------
package Geek::Routes;
use base qw|Object::Accessor|;
use Data::Dumper;


sub need_files{
 # need_files($type) - is alias for: files(type=>$type)
 my $se = shift or die "self!";
 my $type = shift||"";
 return $se->files(type=>$type);
}

sub files{
 # returns files for given conditions
 # sample: files(type=>$type), files(type=>$type, files=>"<2")
 # alias for from_routes( "files", type=>$type, files=>"<2" )
 my $se = shift or die 'self!';
 my %cond = ( files => ">0", @_ ) ;
 return $se->from_routes( "files", %cond );
}

sub types{
 # returns list of types in routes
 # sample: $matched->types() OR $matched->types(arg=>"../my/file.gz")
 # alias for from_routes( "types", type=>$type, ... )
 my $se = shift or die 'self!';
 my %cond = ( files => ">0", @_ ) ;
 return $se->from_routes( "type", %cond );
}

sub from_routes{
 # returns "files"|"types"|... (- see first argument) for given conditions
 # sample: from_routes("files", type=>$type), files(type=>$type, files=>"<2")
 my $se = shift or die 'self!';
 my $return_field = shift or die "return field!";
 my %cond = ( files => ">0", @_ ) ;
 warn "Conditions:".Dumper(\%cond) if $se->debug;
 my %rv;
 $se->routes() or die "routes is empty";
 for my $r ( @{ $se->routes() } ){
    my $ddesc = "Route: (".join( ",  ", map {"$_=$r->{$_}"} keys %$r).")";
    my $allow = 1;
    my @normal_keys = grep { defined $cond{$_} and $cond{$_} ne "" } keys %cond;
    for my $cond_name ( @normal_keys ){
	my $cond_wanted_val = $cond{ $cond_name };
	if ( not exists $r->{$cond_name} ){
	    die "Field '$cond_name' - not exists in route: ".Dumper( $r );
	}
	my $route_property_val = $r->{$cond_name};
	$ddesc.="\n\tcondition_name='$cond_name', cond_wanted_val='$cond_wanted_val', route_property_val='$route_property_val'";

	if ( ref $cond_wanted_val eq "Regexp" ){ 
	    if ( not $route_property_val=~$cond_wanted_val ){ $allow = 0 } # example: type=>qr/bid\w+/
	}elsif( !ref $cond_wanted_val ){
	    if ( !ref $route_property_val ){
		if ( $route_property_val ne $cond_wanted_val ){ $allow = 0 } # example: type=>"bids"
	    }elsif( ref $route_property_val eq "ARRAY" ){
		if ( $cond_wanted_val=~/([\>\<])(\d+)/ ){
		    $ddesc.="\n\troute_property_val='".scalar(@$route_property_val)."' cond=$1, value=$2";
		    if ( $1 eq "<" ){  
			if ( @$route_property_val >= $2 ){  $allow = 0 } # example: files=>"<2"
		    }elsif( $1 eq ">" ){
			if ( @$route_property_val <= $2 ){  $allow = 0 } # example: files=>">0"
		    }
		}
	    }
	}
	$ddesc.="\n\tallow=".($allow||0);
    }
    $ddesc.="\n\tRESUME: allow=$allow";
    warn $ddesc if $se->debug;
    if ($allow){
	$ddesc.="\n\t $return_field='$r->{$return_field}'";
	
	if ( !ref $r->{$return_field} ){
	    my $return_field_value = $r->{$return_field}||"";
	    $ddesc.="\n\t will return $return_field=$return_field_value";
	    $rv{ $return_field_value } +=1;
	}elsif( ref $r->{$return_field} eq "ARRAY" ){
	    my $return_field_vaue = $r->{$return_field};
    	    $ddesc.="\n\tadd to return: \n\t\t".join("\n\t\t", @$return_field_vaue );
    	    for my $el ( @$return_field_vaue ){
        	$rv{ $el } +=1;
    	    }	    
	}else{
	    my $return_field_value = $r->{$return_field};
	    $ddesc.="\n\tadd to return: \n\t\t $return_field_value";
	    $rv{ $return_field_value } +=1;
	}
    }
 }
 
 my @rv = sort keys %rv;

 if (wantarray){
    return @rv;
 }else{
    return \@rv
 }    
}


1;

#-----------------------------------------------------------------
package Geek::Days;
use base qw|Object::Accessor|;

sub files{
 my $se = shift or die "se!";
 my $tmpl = shift or die "tmpl!";
 my @rv;
 for my $d ( @{ $se->days() } ){
    my $file = $tmpl;
    $file=~s/\%F/$d/g;
    push @rv, $file;
 }
 if (wantarray){
    return @rv;
 }else{
    my $files = Geek::Files->new('files');
    $files->files(\@rv);
    return $files;
 }
}

#----------------------------------------------------------------
package Geek::Files;
use base qw|Object::Accessor|;




1;
