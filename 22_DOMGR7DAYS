#!/usr/bin/env bash
#> dom_gr.txt за 7 дней -----> dom_gr7days.gz
#> Для домена выбирает кластер: последний из самых частых за 7 дней.
 
(
set -u
set +x
set -o pipefail
cd `dirname $0`

job=${1:?Job!}
days=${2:-""} # можно указать "$day1 $day2 ..."
deb=${3:-""} # можно указать "deb"

[[ -n "$deb" ]] && set -x

typenum=$(
 href -dict="
     net_sites => '0',
 " -default="3" -val="$job"
)


if [[ -n "$days" ]]; then
    ff=`echo "$days" | files "../RESULT/10/%F/$job/$typenum/dom_gr.txt" | only -s`
else
    ff=`find ../RESULT/10 -wholename "*/[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]/$job/$typenum/dom_gr.txt" | sort -r |
     only --without="dom_gr7days.gz dom_gr6days.gz dom_gr5days.gz dom_gr4days.gz dom_gr3days.gz dom_gr2days.gz dom_gr1days.gz"`   
fi

      
days=`echo "$ff" | fn2days`

[[ -z "$days" ]] && exit 0
for day in $days; do

    src_ff=`hours -t=${day}T00 -shift=1day -n=-7days -days | files "../RESULT/10/%F/$job/$typenum/dom_gr.txt" | only -s` # сколько есть, желательно 7
    [[ -z "$src_ff" ]] && continue
    
    # сколько файлов dom_gr.txt 
    realN=`echo $src_ff | words -count`
    
    result_f="../RESULT/10/$day/$job/$typenum/dom_gr${realN}days.gz"
    
    already_exists=`find "../RESULT/10/$day/$job/$typenum" -wholename 'dom_gr*days.gz'`
    [[ -n "$already_exists" ]] && continue
    #find "../RESULT/10/$day/$job/$typenum" -wholename 'dom_gr*days.gz'
    #echo "$result_f" | only -all -sizegt=20 -nop && continue    
    
    LANG=POSIX mergef -ff="$src_ff" -k=1,1 -k=2,2n -k=3,3 -prefilter="awk -F* -vOFS=* -vfile=\$(date -d\$( fn2days %file) +%s) '{print \$0,file}'" --stdout |
    lae -lb="dom cluster daysec" -comm="daysec - это дата файла-источника dom_gr.txt в секундах" '
    my %h;
    _{
	if ( prevDom and ( prevDom ne Dom )){ domain_end() }
	$h{ $F[DOM] }{ $F[DAYSEC] } = $F[CLUSTER];
    } -prev=>"dom";
    domain_end();
    
    sub domain_end{
	my $dom = prevDom();
	my $sec_cluster = $h{ prevDom() };
	my %stat;
	for my $sec ( keys %$sec_cluster ){
	    $stat{ $sec_cluster->{$sec} }{count}++;
	    $stat{ $sec_cluster->{$sec} }{ maxsec } = $sec if $sec > ($stat{ $sec_cluster->{$sec} }{ maxsec }||0);
	}   

	my $best_cluster = [ sort { $stat{$b}{count}.$stat{$b}{maxsec} <=> $stat{$a}{count}.$stat{$a}{maxsec} } keys %stat ]->[0];
	p $dom, $best_cluster; # debug:, join(",", map {"$_=>$sec_cluster->{$_}"} keys %$sec_cluster);
	delete $h{ prevDom() };	
    }
    ' | gzip > $result_f.TMP && mv $result_f.TMP $result_f     
done


#> OUT:
#> dom, group (a.k.a. cluster)

)>>"$0.log" 2>&1
