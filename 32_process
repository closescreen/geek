#!/usr/bin/env bash
#> Объединение смерженных за {deep} дней uidsz с gender, age, ctr_&_inactive 
#>> gender: 
#>>  11 - 2.54 муж
#>>  12 - 2.55 жен
#>> age:
#>>  1 - 2.56 young (12-24)
#>>  2 - 2.57 adult (25-44)
#>>  3 - 2.60 old (45+) 
#>> ctr: 1(most active)..10 groups + 11=inactive      
set -u
set -x
set -o pipefail
set -e

#>> Дается имя текущего uidsz.gz
srcfile=${1:?File!} # ../REESULT/.../uidsz.gz
#>> Дается job (напр. google)
job=${2:?Job!} # google
#>> Задается глубина дней, за сколько мержить uidsz
deep=${3:?Deep!} # в днях (30), за сколько дней нужны uidsz.gz
#>> Указывается основная папка файлов трейтов. 
gender_tmpl=${4:?gender_tmpl!} # шаблон имени gender
age_tmpl=${5:?age_tmpl!} # шаблон age
ctr10_tmpl=${6:?ctr10_tmpl!} # шаблон ctr10

#>> по имени текущего uidsz получает текущий день
day=`fn2days "$srcfile"`

#>> по текущему дню получает имя соответствующего predict_add файла из трейтов по gender и проверяет его существование:
gender_file=`files "$gender_tmpl" "$day"`
chk "$gender_file" "gender file" "-s" "exists" nop || exit 2

#>> тоже для age:
age_file=`files "$age_tmpl" "$day"`
chk "$age_file" "age file" "-s" "exists" nop || exit 2

#>> тоже для ctr-групп:
ctr10_file=`files "$ctr10_tmpl" "$day"`


#>> по текущему дню и {deep}, вычисляет за какие дни мержить
nextday=`hours -d="$day" -n=2days -last -day`
#>> deep дней, включая day: 
days=`hours -d="$nextday" -n=-"$deep"days -days`
#>> по дням вычисляет соответствующие файлы uidsz.gz:
ff=`files "../RESULT/10/%F/$job/3/uidsz.gz" "$days"`
#>> должны все присутствовать и быть >20b:
exists_files=`echo "$ff" | only -all -s | only -sizegt=20`
chk "$exists_files" "For files deep=$deep days, not found $? nonempty files." "$_" "found all files" nop || exit 3

#>> мержит все uidsz, уникалит и подает на вход скриту
mergef -ff="$exists_files" -m -k=1,1n -k=2,2n -stdout |
uniq |
lae -lb="uid sz" '
open GENDER, shift or die "cant open GENDER file!";
open AGE, shift or die "cant open AGE file!";
my $gender_line="";
my $gender_uid=-1;
my $gender_gr=-1;

my $age_line="";
my $age_uid=-1;
my $age_gr=-1;

_{
 #>> на входе отуникаленные uid sz, отсортированный по uid
 
 while ( $gender_uid < Uid ){
    if ( !defined( $gender_line = <GENDER>) ){
	die $! if $!;
	last;
    }
    chomp($gender_line);
    ($gender_uid, $gender_gr) = split /\*/, $gender_line;
 }
 
 while ( $age_uid < Uid ){
    if ( !defined( $age_line = <AGE>) ){
	die $! if $!;
	last;
    }
    chomp($age_line);
    ($age_uid, $age_gr) = split /\*/, $age_line;
 } 



 #>> OUT:
 #>>  uid sz gendered_group age_group
 p0 Uid, Sz, ($gender_uid == Uid ? $gender_gr : 0), ($age_uid == Uid ? $age_gr : 0);
};
' "$gender_file" <(zcat $age_file) # gender_file не gzip'нутый, age - gzip-нутый

